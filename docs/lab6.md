# Lab6: 文件系统

在这个实验中，你将向 xv6 文件系统中添加大文件和符号链接。

在编写代码之前，你应该阅读 xv6 书中的“第8章：文件系统”，并研究相应的代码。

获取实验的 xv6 源码并切换到 util 分支：

```bash
$ git fetch
$ git checkout fs
$ make clean
```

## 磁盘的多级映射

难度：中等

在这个任务中，你将增加 xv6 文件的最大大小。目前，xv6 文件被限制为 268 个块，或者 268*BSIZE 字节（在 xv6 中，BSIZE 为 1024）。这个限制源于一个事实，即一个 xv6 inode 包含 12 个“直接”块号和一个“间接”块号，后者指向一个最多包含 256 个块号的块，总共可以达到 12+256=268 个块。

`bigfile` 命令创建尽可能长的文件，并报告该大小：

```bash
$ bigfile
..
wrote 268 blocks
bigfile: file is too small
$
```

这个测试失败是因为 `bigfile` 期望能够创建一个由 65803 个块组成的文件，但未修改的 xv6 将文件限制为 268 个块。

你将改变 xv6 文件系统代码，以支持每个 inode 中的“双重间接”块，其中包含 256 个单一间接块的地址，每个间接块可以包含最多 256 个数据块的地址。结果将是，文件将能够由最多 65803 个块组成，或者 256*256+256+11 个块（11 个直接块而不是 12 个，因为我们将牺牲一个直接块号用于双重间接块）。

**准备工作：**

`mkfs` 程序创建 xv6 文件系统磁盘映像，并确定文件系统的总块数；这个大小由 kernel/param.h 中的 FSSIZE 控制。你将看到此实验的存储库中的 FSSIZE 设置为 200,000 个块。你应该从 `make` 输出中看到以下输出：

```bash
nmeta 70 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 25) blocks 199930 total 200000
```

此行描述了 `mkfs` 构建的文件系统：它有 70 个元数据块（用于描述文件系统的块）和 199,930 个数据块，总共 200,000 个块。

如果在实验过程中你发现自己不得不从头开始重建文件系统，你可以运行 `make clean`，这会强制 `make` 重新构建 `fs.img`。

**需要查看的内容：**

- 在 `fs.h` 中，一个磁盘上的 inode 的格式由 `struct dinode` 定义。你特别关注 `NDIRECT`、`NINDIRECT`、`MAXFILE` 和 `struct dinode` 中的 `addrs[]` 元素。查看 xv6 文本中的图 8.3，了解标准 xv6 inode 的结构。

- 在 `fs.c` 中，找到在磁盘上查找文件数据的代码是 `bmap()`。仔细查看它，并确保你理解它在做什么。`bmap()` 在读取和写入文件时都会被调用。在写入时，`bmap()` 会根据需要分配新块来容纳文件内容，并分配一个间接块（如果需要）来容纳块地址。

  `bmap()` 处理两种类型的块号。`bn` 参数是一个“逻辑块号”——文件内的块号，相对于文件的开头。`ip->addrs[]` 中的块号以及传递给 `bread()` 的参数是磁盘块号。你可以将 `bmap()` 视为将文件的逻辑块号映射到磁盘块号。

：

修改 `bmap()` 函数，使其实现双重间接块，除了直接块和单一间接块之外。你将不得不只保留 11 个直接块，而不是 12 个，以为新的双重间接块腾出空间；你不允许改变磁盘上 inode 的大小。`ip->addrs[]` 的前 11 个元素应该是直接块；第 12 个应该是单一间接块（就像当前的一样）；第 13 个应该是你的新的双重间接块。当 `bigfile` 写入 65803 个块并且 `usertests -q` 成功运行时，你就完成了这个练习：

```bash
$ bigfile
..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
wrote 65803 blocks
done; ok
$ usertests -q
...
ALL TESTS PASSED
$
```

`bigfile` 将需要至少一分半钟的时间来运行。

**提示：**

- 确保你理解 `bmap()`。画出 `ip->addrs[]`、间接块、双重间接块以及它指向的单一间接块和数据块之间的关系图。确保你理解为什么添加双重间接块会增加最大文件大小 256*256 块（实际上是 -1，因为你必须减少直接块的数量一块）。
- 想一想你将如何使用逻辑块号来索引双重间接块以及它指向的单一间接块。
- 如果你改变了 `NDIRECT` 的定义，你可能需要改变 `file.h` 中 `struct inode` 中 `addrs[]` 的声明。确保 `struct inode` 和 `struct dinode` 中的 `addrs[]` 数组具有相同的元素数量。
- 如果你改变了 `NDIRECT` 的定义，请确保创建一个新的 `fs.img`，因为 `mkfs` 使用 `NDIRECT` 来构建文件系统。
- 如果你的文件系统进入了一个糟糕的状态，可能是因为崩溃，请删除 `fs.img`（在 Unix 中而不是 xv6 中进行此操作）。`make` 会为你构建一个新的干净的文件系统映像。
- 不要忘记对每个你使用 `bread()` 读取的块调用 `brelse()`。
- 你应该像原始的 `bmap()` 一样只在需要时分配间接块和双重间接块。
- 确保 `itrunc` 释放文件的所有块，包括双重间接块。

## 软链接

难度：中等

在这个练习中，你将向 xv6 添加符号链接。符号链接（或软链接）通过路径名引用链接的文件；当打开符号链接时，内核会跟随链接到被引用的文件。符号链接类似于硬链接，但硬链接限制指向同一磁盘上的文件，而符号链接可以跨磁盘设备。虽然 xv6 不支持多个设备，但实现这个系统调用是一个很好的练习，可以理解路径名查找是如何工作的。

**你的任务：**

你将实现 `symlink(char *target, char *path)` 系统调用，该调用在 `path` 处创建一个指向 `target` 命名的文件的新符号链接。有关详细信息，请参阅 `symlink` 的 man 手册页。要进行测试，将 `symlinktest` 添加到 Makefile 中并运行它。当测试生成以下输出时（包括 `usertests` 成功运行）你的解决方案就完成了：

```bash
$ symlinktest
Start: test symlinks
test symlinks: ok
Start: test concurrent symlinks
test concurrent symlinks: ok
$ usertests -q
...
ALL TESTS PASSED
$
```

**提示：**

- 首先，为 `symlink` 创建一个新的系统调用号码，在 `user/usys.pl`、`user/user.h` 中添加一个条目，并在 `kernel/sysfile.c` 中实现一个空的 `sys_symlink`。
- 在 `kernel/stat.h` 中添加一个新的文件类型（`T_SYMLINK`），表示符号链接。
- 在 `kernel/fcntl.h` 中添加一个新的标志（`O_NOFOLLOW`），可以与 `open` 系统调用一起使用。请注意，传递给 `open` 的标志是使用位 OR 运算符组合的，因此你的新标志不应与任何现有标志重叠。这将允许你在将其添加到 Makefile 后编译 `user/symlinktest.c`。
- 实现 `symlink(target, path)` 系统调用，在 `path` 处创建一个指向 `target` 的新符号链接。请注意，`target` 不需要存在即可成功执行系统调用。你需要选择一个地方来存储符号链接的目标路径，例如，inode 的数据块中。`symlink` 应该返回一个表示成功（0）或失败（-1）的整数，类似于 `link` 和 `unlink`。
- 修改 `open` 系统调用，以处理路径指向符号链接的情况。如果文件不存在，则 `open` 必须失败。当进程在 `open` 的标志中指定 `O_NOFOLLOW` 时，`open` 应该打开符号链接（而不是跟随符号链接）。
- 如果链接的文件也是一个符号链接，你必须递归地跟随它，直到达到非链接文件。如果链接形成循环，你必须返回一个错误代码。你可以通过返回一个错误代码来近似这个，如果链接的深度达到某个阈值（例如，10）。
- 其他系统调用（例如，link 和 unlink）不得跟随符号链接；这些系统调用操作的是符号链接本身。
- 对于此实验，你不需要处理对目录的符号链接。