# Lab7: 外部设备

在这个实验中，你将为网络接口卡（NIC）编写一个设备驱动程序，并向 xv6 添加对 UDP 网络套接字的支持。

获取用于实验的 xv6 源代码并检出 net 分支：

```bash
$ git fetch
$ git checkout net
```

## 背景

在编写代码之前，你可能会发现有必要查阅 xv6 书籍中的 "Chapter 4: Traps and device drivers" 和 "Section 7.13: File descriptor layer"，以及网络方面的讲座笔记。

我们将使用名为 E1000 的虚拟网络设备来处理网络通信。对于 xv6（以及你编写的驱动程序），E1000 看起来就像连接到真实以太网局域网（LAN）的真实硬件一样。但实际上，你的驱动程序将与 qemu 提供的仿真相连，该仿真通过 qemu 也进行了仿真。在这个局域网中，xv6（"guest"）的 IP 地址为 10.0.2.15。局域网中唯一的其他（模拟的）计算机的 IP 地址为 10.0.2.2。qemu 安排当 xv6 使用 E1000 发送数据包到 10.0.2.2 时，实际上是将其传递给运行 qemu 的（真实）计算机上的适当应用程序（"host"）。

我们将使用 QEMU 的用户模式网络堆栈，因为它不需要管理权限即可运行。QEMU 的文档在这里提供了有关用户网络的更多信息。我们已经更新了 Makefile，以启用 QEMU 的用户模式网络堆栈和虚拟 E1000 网络卡。

我们还配置了 QEMU 的网络堆栈，以将所有传入和传出的数据包记录到你的实验目录中的 packets.pcap 中。审查这些记录可能有助于确认 xv6 是否发送和接收了你期望的数据包。要获取捕获的数据包的十六进制/ASCII 转储，请像这样使用 tcpdump：

```bash
tcpdump -XXnr packets.pcap
```

最后，我们已经为你提供了处理以太网、IP、UDP 和 ARP 包头的所有所需代码。确保在 kernel/net.c 和 kernel/net.h 中审查这些代码。还提供了一个简单的抽象，称为 mbuf，用于存储和管理数据包负载。它将在整个实验任务中使用。

## 网络设备驱动程序

难度：困难

在这部分任务中，你将完成 E1000 网络驱动程序的实现。到目前为止，已经提供了用于发现和初始化设备以及处理中断的代码，但还没有发送和接收数据包。

浏览 Intel 的 E1000 软件开发手册。该手册涵盖了几个密切相关的以太网控制器。QEMU 模拟的是 82540EM。现在可以略读第 2 章以了解设备的情况。为了编写你的驱动程序，你需要熟悉第 3 章和第 14 章，以及第 4.1 节（不包括 4.1 的子节）。你还需要使用第 13 章作为参考。其他章节主要涵盖你的驱动程序不必与之交互的 E1000 组件。现在不必担心细节；只需了解文档的结构，以便稍后查找。请记住，E1000 有许多高级功能，但你可以忽略其中大多数。只需要一小部分基本功能即可完成实验任务。

**你的任务：**

你的任务是实现发送和接收数据包的支持。你需要在 kernel/e1000.c 中填写 e1000_recv() 和 e1000_transmit() 中的缺失部分。

发送和接收数据包都由在内存中 xv6 和 E1000 之间共享的描述符队列管理。这些队列为 E1000 提供了进行 DMA（即传输）数据包数据的内存位置的指针。它们实现为循环数组，这意味着当卡片或驱动程序到达数组的末尾时，它会回到开始。一个常见的缩写是将接收数据结构称为 RX，将传输数据结构称为 TX。

当新数据包到达时，E1000 会生成中断。你的接收代码必须扫描 RX 队列以处理已到达的每个数据包，并通过调用 net_rx() 将其 mbuf 传递给协议层。struct rx_desc 描述了描述符的格式。然后，你需要分配一个新的 mbuf，并将其程序到描述符中，以便 E1000 知道在以后的某个时候当数据包到达相同的位置时应放置在何处。

当协议层调用 e1000_transmit() 时，会请求发送数据包。你的传输代码必须将 mbuf 加入 TX 队列。这包括从内存中提取负载的位置和长度，并将这些信息编码到 TX 队列中的描述符中。struct tx_desc 描述了描述符的格式。你需要确保 mbuf 在传输完成后最终被释放（NIC 可以在描述符中编码一个通知位以指示这一点）。

除了读取和写入描述符的循环数组之外，你还需要通过内存映射 I/O 与 E1000 进行交互，以便检测到接收路径上的新描述符，并通知 E1000 新描述符已在传输路径上提供。设备的 I/O 指针存储在 regs 中，并且可以作为控制寄存器的数组进行访问。你将需要特别使用 E1000_RDT 和 E1000_TDT 的索引。

**提示：**

确保考虑到锁定。通常，当内存是共享的时候，需要使用锁来同步访问。

以下是一些发送的提示：

- 对于传输，首先获取当前的环位置，使用 E1000_TDT。
- 然后检查环是否溢出。如果当前描述符中未设置 E1000_TXD_STAT_DD，则表示先前的传输仍在进行中，因此返回错误。
- 否则，使用 mbuffree() 释放上一个使用当前描述符传输的 mbuf（如果有的话）。
- 然后填充描述符，提供新 mbuf 的头指针和长度。设置必要的 cmd 标志（阅读 E1000 手册）。并将新 mbuf 的指针保存在一个变量中，以便稍后释放。
- 最后，通过将 E1000_TDT 加 1 取模 TX_RING_SIZE 来更新环位置。
- 如果传输成功地将 mbuf 添加到环中，则返回 0（否则，调用方将释放 mbuf）。如果失败（例如，没有可用的描述符来传输 mbuf），则返回 -1（以便调用方知道要释放 mbuf）。

以下是一些接收的提示：

- 首先获取下一个环位置，使用 E1000_RDT 加一取模 RX_RING_SIZE。
- 然后检查是否有新数据包可用，通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位。如果没有，停止。
- 否则，更新 mbuf 的长度以匹配描述符中报告的长度（例如，使用 mbufput()）。使用 net_rx() 将 mbuf 传递到协议层。（e1000_init() 最初为接收环中的每个槽分配了一个 mbuf。）
- 然后分配一个新的 mbuf（因为 net_rx() 可能会占用传递给它的 mbuf），并将其头指针程序到描述符中。将描述符的状态位清零。
- 最后，通过写入来更新 E1000_RDT 寄存器以到达下一个位置。

**最后：**

当你完成了 E1000 驱动程序的缺失部分的实现后，以下是一些测试的提示。我们提供了一个工具，可以通过键入 `make ping` 在终端中运行它。请小心在运行它的同一台机器上运行它，该机器正在运行 QEMU 中的 xv6 内核实例。ping 工具将每秒发送一个 UDP 数据包到你的网络堆栈。在 e1000_recv() 函数中添加 printf 来验证你是否收到每个 UDP ping 数据包。特别是，检查是否可以接收超过 16 个数据包（描述符环的大小）。如果遇到问题，检查 packets.pcap 是否有助于查看你的 E1000 驱动程序是否正常工作。在 e1000_transmit() 和 e1000_recv() 中添加 printf 也可能有助于调试。

## 网络套接字

难度：困难

现在你已经完成了 E1000 驱动程序，你需要支持用户空间应用程序。为了帮助你，提供了一个名为 nettests 的测试用户程序，但你首先需要实现对网络套接字的支持，以便它可以与 xv6 交互。

网络套接字是 OS 网络的标准抽象，类似于文件。套接字通过普通的文件描述符（就像文件、管道和设备一样）进行访问。从套接字文件描述符读取接收一个数据包，而写入它则发送一个数据包。如果当前没有可接收的数据包，读取者必须阻塞并等待下一个数据包到达（即允许重新调度到另一个进程）。在这个实验中，你将实现一个支持 UDP 网络协议的精简版本的套接字。

每个网络套接字只接收特定本地和远程 IP 地址和端口号组合的数据包，并且 xv6 需要支持多个套接字。可以通过 connect 系统调用创建套接字并将其绑定到请求的地址和端口。此系统调用的实现在 kernel/sysfile.c 中。在 kernel/sysnet.c 中的代码 sockalloc() 和相关函数。

注意所提供的数据结构；为每个套接字创建一个 struct sock 对象。sockets 是所有活动套接字的单链表。它有助于查找要传递新接收到的数据包的套接字。此外，每个套接字对象维护一个等待接收的 mbuf 队列。收到的数据包将保留在这些队列中，直到读取() 系统调用将它们出队。

**你的任务：**

你的任务是实现支持网络套接字所需的缺失功能。这包括添加和集成支持读取、写入和关闭套接字的函数。还包括完成 sockrecvudp() 的实现，每次接收到新的 UDP 数据包时都会调用它。为了实现这一点，请填写 kernel/sysnet.c 中的缺失部分，并修改 kernel/file.c 来调用你的套接字方法。

**提示：**

以下是一些提示：

- 仔细阅读 kernel/pipe.c。它提供了实现一种文件类型的示例。套接字是另一种文件类型，它们将需要相同的文件方法。
- 在 kernel/defs.h 中定义你的套接字方法，包括读取、写入和关闭。通过检查套接字类型是否为 FD_SOCK，将每个方法集成到 kernel/file.c 中的适当调用点。
- 对于读取方法，请使用 mbufq_empty() 检查 rxq 是否为空，如果是，请使用 sleep() 等待直到 mbuf 入队（不要忘记将 sleep() 调用包装到 while 循环中，因为其他使用 sleep() 的地方也是如此）。使用 mbufq_pophead，从 rxq 弹出 mbuf，并使用 copyout() 将其负载移动到用户内存中。最后使用 mbuffree() 释放 mbuf 完成。
- 对于写入方法，请分配一个新的 mbuf，确保为 UDP、IP 和以太网标头保留足够的头部空间。使用 mbufput() 和 copyin() 将负载从用户内存传输到 mbuf 中。最后，使用 net_tx_udp() 发送 mbuf。
- 对于关闭方法，请从 sockets 列表中移除套接字。然后，释放套接字对象。在释放 struct sock 之前，请务必先释放任何未读取的 mbuf。
- 对于 sockrecvudp()，确定哪个套接字（如果有）可以处理 mbuf，并将其传递到适当的 rxq。使用 wakeup() 唤醒任何等待的读取器。
- 不要忘记在整个过程中考虑到锁定！

**将所有内容整合起来：**

当你完成后，请运行测试程序。如果一切正常，你将获得以下输出：

（在主机的一个终端上）

```bash
$ make server
python2 server.py 26099
listening on localhost port 26099
```

（然后在另一个终端上运行 xv6）

```bash
nettests
```

如果遇到任何问题，请尝试检查 packets.pcap，以查看你的 E1000 驱动程序是否正常工作。在 e1000_transmit() 和 e1000_recv() 中添加 printf 也可能有助于调试。

这完成了实验。提交你的更改，并在实验目录中键入 `make handin` 以提交你的实验。

请运行 `make grade` 来确保你的代码通过了所有测试。在运行 `make handin` 之前提交任何修改过的源代码。