# Lab4: 页表

在这个实验中，你将探索页面表并修改它们以加速某些系统调用，并检测已访问的页面。

在开始编码之前，请阅读 xv6 书的第 3 章，并查阅相关文件：

- kernel/memlayout.h，捕获内存布局。
- kernel/vm.c，包含大部分虚拟内存（VM）代码。
- kernel/kalloc.c，包含用于分配和释放物理内存的代码。
- 也许还有助于查阅 RISC-V 特权架构手册。

要开始这个实验，请切换到 pgtbl 分支：

```bash
$ git fetch
$ git checkout pgtbl
$ make clean
```

### **加速系统调用**

难度：简单

一些操作系统（例如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加速某些系统调用。这消除了执行这些系统调用时内核跨越的需要。为了帮助你学习如何向页表中插入映射，你的第一个任务是为 xv6 中的 `getpid()` 系统调用实现这种优化。

在每个进程创建时，在 `USYSCALL`（在 `memlayout.h` 中定义的虚拟地址）处映射一个只读页面。在该页面的开头，存储一个 `struct usyscall`（也在 `memlayout.h` 中定义），并初始化为存储当前进程的 PID。为了通过这一部分实验，你需要确保在运行 `pgtbltest` 时通过了 `ugetpid` 测试用例。

**提示：**

- 选择允许用户空间只读取页面的权限位。
- 在新页面的生命周期中需要执行一些操作。可以参考 `kernel/proc.c` 中的 trapframe 处理。
- 这种共享页面可以用于加速哪些其他 xv6 系统调用？解释一下为什么。

### **打印Xv6的根页面**

难度：简单

为了帮助你可视化 RISC-V 页表，并可能有助于未来的调试，你的第二个任务是编写一个函数，用于打印页表的内容。

定义一个名为 `vmprint()` 的函数。它应该接受一个 `pagetable_t` 参数，并按照下面描述的格式打印该页表。在 `exec.c` 中的 `return argc` 之前插入 `if(p->pid==1) vmprint(p->pagetable)`，以打印刚完成 `init` 的第一个进程的页表。当你完成这一部分实验后，通过了 `make grade` 的 `pte printout` 测试即可。现在当你启动 xv6 时，它应该输出像下面这样的内容，描述在刚刚完成 `exec()` 的 `init` 进程时，第一个进程的页表：

```bash
page table 0x0000000087f6b000
 ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000
 .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000
 .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000
 .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000
 .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000
 .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000
 ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000
 .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
init: starting sh
```

**提示：**

- 你可以将 `vmprint()` 放在 `kernel/vm.c` 中。
- 使用 `kernel/riscv.h` 文件末尾的宏。
- `freewalk` 函数可能会给你一些灵感。
- 在 `kernel/defs.h` 中定义 `vmprint` 的原型，以便从 `exec.c` 中调用它。
- 在你的 `printf` 调用中使用 `%p`，以打印出完整的 64 位十六进制 PTE 和地址。

### **检测页面是否被访问**

难度：困难

在本实验的这一部分中，你将向 xv6 添加一个新功能，即通过检查 RISC-V 页表中的访问位来检测和报告哪些页面已经被访问。当 RISC-V 硬件页行程器解决 TLB 未命中时，它会在 PTE 中标记这些位。

实现 `pgaccess()`，一个报告哪些页面已被访问的系统调用。系统调用有三个参数：首先，它获取要检查的第一个用户页面的起始虚拟地址。其次，它获取要检查的页面数。最后，它获取一个用户地址，指向一个缓冲区，用于将结果存储为位掩码（一种数据结构，每页使用一个位，其中第一页对应最低有效位）。你需要确保在运行 `pgtbltest` 时通过了 `pgaccess` 测试用例。

**提示：**

- 阅读 `user/pgtbltest.c` 中的 `pgaccess_test()`，了解如何使用 `pgaccess`。
- 首先在 `kernel/sysproc.c` 中实现 `sys_pgaccess()`。
- 你需要使用 `argaddr()` 和 `argint()` 来解析参数。
- 对于输出位掩码，更容易的方法是在内核中存储一个临时缓冲区，并在填充正确位后将其复制到用户空间（通过 `copyout()`）。
- 对可扫描的页面数量设置一个上限是可以接受的。
- `kernel/vm.c` 中的 `walk()` 对于找到正确的 PTE 非常有用。
- 你需要在 `kernel/riscv.h` 中定义 `PTE_A`，即访问位。
- 确保在检查完之后清除 `PTE_A`。否则，将无法确定页面自上次调用 `pgaccess()` 以来是否被访问（即该位将永远被设置）。
- `vmprint()` 可能对调试页表很有用。

### Copy-on-Write

难度：困难

本实验将探索一个系统问题的解决方案：Copy-on-Write Fork。通过实现该功能，你将熟悉虚拟内存和页表的相关概念，并学习如何在内核中实现 Copy-on-Write。

要开始这个实验，请切换到 cow 分支：

```bash
$ git fetch
$ git checkout cow
$ make clean
```

**问题**

在 xv6 中，fork() 系统调用会将父进程的所有用户空间内存复制到子进程中。如果父进程很大，复制过程会耗费大量时间。更糟糕的是，这项工作通常是浪费的：fork() 通常会在子进程中跟随 exec()，这会丢弃已复制的内存，而且通常没有使用其中大部分。另一方面，如果父进程和子进程都使用了复制的页面，并且其中一个或两个写入了它，那么这个复制就是真正需要的。

**解决方案**

Copy-on-Write (COW) Fork 的目标是推迟分配和复制物理内存页面，直到实际需要。实现该功能的关键在于延迟复制，直到要修改页面内容时才执行复制操作。

COW fork() 为子进程创建一个页表，其中的用户内存的页表项 (PTE) 指向父进程的物理页面。父进程和子进程中的所有用户 PTE 都标记为只读。当任一进程尝试写入这些 COW 页面时，CPU 将引发页面错误。内核页面错误处理程序检测到这种情况后，会为引发错误的进程分配一个物理内存页面，将原始页面复制到新页面，并修改引发错误的进程中的相应 PTE，使其指向新页面，并标记为可写。页面错误处理程序返回后，用户进程将能够写入其页面的副本。

**实验任务**

你的任务是在 xv6 内核中实现 Copy-on-Write Fork。完成后，你的修改内核应该能够成功执行 cowtest 和 'usertests -q' 程序。

**以下是一个合理的计划：**

1. 修改 uvmcopy()，将父进程的物理页面映射到子进程中，而不是分配新页面。对于已标记为 PTE_W 的页面，清除子进程和父进程的 PTE 中的 PTE_W 标志。
2. 修改 usertrap()，识别页面错误。当写页面错误发生在原本可写的 COW 页面上时，使用 kalloc() 分配一个新页面，将旧页面复制到新页面，并将新页面安装到具有 PTE_W 设置的 PTE 中。原本是只读的页面（未映射 PTE_W，例如文本段中的页面）应保持只读，并在父进程和子进程之间共享；尝试写入此类页面的进程应被终止。
3. 确保每个物理页面在最后一个引用它的 PTE 消失时释放 -- 但不是之前。一种良好的方法是为每个物理页面保留一个“引用计数”，表示引用该页面的用户页表数量。当 kalloc() 分配页面时，将页面的引用计数设置为一。当 fork 导致子进程共享页面时，增加页面的引用计数，并且每次任何进程从其页表中删除页面时，减少页面的计数。只有当页面的引用计数为零时，kfree() 才应将页面放回空闲列表。你可以在一个固定大小的整数数组中保持这些计数。你需要设计一种方案来索引数组以及选择其大小。例如，你可以用页面的物理地址除以 4096 来索引数组，并给数组分配与 kalloc.c 中 kinit() 放置在空闲列表中的任何页面的最高物理地址相等的元素数。你可以自由修改 kalloc.c（例如，kalloc() 和 kfree()）以维护引用计数。
4. 修改 copyout()，当遇到 COW 页面时，使用与页面错误相同的方案。

**提示：**

- 为了记录每个 PTE 是否是 COW 映射，可能有一种方法是使用 RISC-V PTE 中的保留位（reserved for software）。
- usertests -q 探索 cowtest 未测试的场景，所以不要忘记检查所有测试是否都通过。
- 有关页面表标志的一些有用的宏和定义位于 kernel/riscv.h 的末尾。
- 如果发生 COW 页面错误并且没有空闲内存，则应终止该进程。

